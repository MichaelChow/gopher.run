---
title: "1.6 包、模块与测试"
date: 2025-07-26T12:02:00Z
draft: false
weight: 1006
---

# 1.6 包、模块与测试

## 一、Go package

Go 程序是通过将包链接在一起构建的。一个包由一个或多个源文件构成，这些文件共同声明属于该包的常量、类型、变量和函数，并且可以在同一包的所有文件中访问。这些元素可以被导出并在另一个包中使用。



一个中等规模的程序可能包含10000个函数，但是作者可能只须思考它们其中的10%，甚至不需要设计函数，因为绝大部分都是其他人来写的，通过包来复用。

**任何包管理系统的目的，都是通过对关联的特性进行分类，组织成便于理解和修改的单元**，使其与程序的其他包保持独立，从而有助于设计和维护大型的程序。

模块化允许包在不同的项目中共享、复用，在组织中发布，或者在全世界范围内使用。

Go标准库目前已有344个包，为大多数的程序提供了必要的基础构件。

```shell
(base) ➜  ~ go version
go version go1.24.4 darwin/arm64
(base) ➜  ~ go list std | wc -l
     344
```

Go社区有很多成熟的包被设计、共享、重用和改进，可以通过 [http://godoc.org](http://godoc.org/) 检索。

![](/images/23c24637-29b5-8014-bcb6-d0963c7c66e3/image_23b24637-29b5-80d6-9d38-d5f3cfbd1570.jpg)





- 官方Go module proxy： [https://proxy.golang.org/](https://proxy.golang.org/)
- 国内七牛云Go module proxy： [https://goproxy.cn/](https://goproxy.cn/)




**每个包定义了一个不同的命名空间，来作为它的标识符**。

包通过控制名字是否导出使其对包外可见来提供封装能力。限制包成员的可见性，从而隐藏API后面的辅助函数和类型，允许包的维护者修改包的实现而不影响包外部的代码。限制变量的可见性也可以隐藏变量，这样使用者仅可以通过导出函数来对其访问和更新，他们可以保留自己的不变量以及在并发程序中实现互斥的访问。



Go程序的编译比其他语言要快，主要原因有三：

- 原因1：所有的导入都必须在每一个源文件的**开头进行显式声明**，这样编译器在确定依赖性的时候就不需要读取和处理整个文件；
- 原因2：包的依赖性形成**有向无环图**，因为没有环，所以包可以独立甚至并行编译；**每个导入声明从当前包向导入的包建立一个依赖。如果有循环依赖，go build工具会报错**。
- 原因3：Go包编译输出的目标文件不仅记录它自己的导出信息，**还记录它所依赖包的导出信息**。当编译一个包时，编译器必须从每一个导入中读取一个目标文件，但是不会超出这些文件（译注：**很多都是重复的间接依赖**）。


导入路径：每一个包都通过一个唯一的字符串进行标识（称为导入路径、包名），用在import声明中；为了避免冲突，除了标准库中的包之外，其他包的导入路径应该**以网站域名作为路径开始**，这样也方便查找包。**通过空行进行分组，通常表示不同领域和方面的包**。

导入顺序不重要，但按照惯例每一组都按照字母进行排序。（gofmt和goimports工具都会自动进行分组并排序。）

Go在坚持其强硬的导入的包必须有使用和代码格式化规则的设计哲学下，通过提供**goimports****工具和****gofmt工具**，使得程序员在编辑器保存时，自动添加或删除导入的包、自动格式化Go源文件，实现无缝体验。（类似透明加解密）

```sql
import (
    "crypto/rand"
		 mrand "math/rand"

    "golang.org/x/net/html"

    "github.com/go-sql-driver/mysql"
)
```

**导入重命名：**

- 如果需要把两个名字一样的包（如math/rand和crypto/rand）导入到第三个包中，导入声明就必须至少为其中的一个指定一个替代名字来避免冲突；
- 如果有时用到自动生成的代码，导入的包名字非常冗长，使用一个替代名字可能更方便。同样的缩写名字要一直用下去，以避免产生混淆；
- 空导入：当需要对包级别的变量执行初始化表达式求值，并执行它的init函数，但又未使用包时，会有“unused import”编译错误。Go的`_`空白标识符，并不能被访问(这里区别于python)；
```go
package png /
import  _ "image/png" // register PNG decoder 

// 最终的效果是，主程序只需要匿名导入特定图像驱动包就可以用image.Decode解码对应格式的图像了。
func Decode(r io.Reader) (image.Image, error)
func DecodeConfig(r io.Reader) (image.Config, error)

func init() {
    const pngHeader = "\x89PNG\r\n\x1a\n"
    image.RegisterFormat("png", pngHeader, Decode, DecodeConfig)
}
```

**包的import声明**：在每一个Go源文件的开头都需要进行包声明。通常包名是导入路径的最后一段，但有3个例外：

- 例外1-main：如果包定义一个可执行程序，总是使用包名字main，这是告诉go build的信号，它必须调用连接器生成可执行文件；`package main`
- 例外2-_test：包所在的目录中可能有一些文件名字以_test.go结尾，包名中会出现以_test结尾。这样一个目录中有两个包：一个普通的，加上一个外部测试包。**_test后缀的外部拓展包由go test独立编译，并且指明文件属于哪个包**。外部测试包一般用来**避免测试代码中的循环依赖**
- 例外3-yaml.v2：一些依赖版本号的管理工具会在导入路径后追加版本号信息，如“gopkg.in/yaml.v2”。这种情况下**包的名字并不包含版本号后缀**，而是yaml。
```go
// 数据库包database/sql也是采用了类似的技术，让用户可以根据自己需要选择导入必要的数据库驱动。例如：
import (
    "database/sql"
    _ "github.com/lib/pq"              // enable support for Postgres
    _ "github.com/go-sql-driver/mysql" // enable support for MySQL
)

db, err = sql.Open("postgres", dbname) // OK
db, err = sql.Open("mysql", dbname)    // OK
db, err = sql.Open("sqlite3", dbname)  // returns error: unknown driver "sqlite3"
```



**包的命名约定：**

**当创建一个包，一般要用短小的包名，但也不能短到像加了密一样**。标准库中最常用的包有bufio、bytes、flag、fmt、http、io、json、os、sort、sync和time等包；

尽可能保持命名的**可读性和无歧义**。如imageutil、ioutilis等名称更具体和清晰，而不要把辅助工具包命名为util

避免选择经常用于相关的局部变量的包名，或者迫使使用者使用重命名导入，如使用以path命名的包。

包名通常使用统一的形式。标准包bytes、errors和strings使用复数来避免覆盖响应的预声明类型，使用go/types这个形式，来避免和关键字的冲突。

避免使用有其他含义的包名，如temperature用tempconv，能和strconv等类似。

包成员命名，需要同时考虑包名和成员名两个部分如何很好地组合命名。下面有一些例子：bytes.Equal、flag.Int、http.Get、json.Marshal

还有一个**以New命名的函数用于创建实例：**

```go
package rand // "math/rand"

// 这可能导致一些名字重复，如template.Template或rand.Rand，这就是为什么这些种类的包名往往特别短的原因之一。
type Rand struct{ /* ... */ }
func New(source Source) *Rand
```

在另一个极端，像net/http包有将近二十种类型和更多的函数，但包中最重要的成员名字却依然是保持简单明了的：Get、Post、Handle、Error、Client、Server等。



Go的命令行接口使用“瑞士军刀”风格，带有十几个子命令，如get、run、build和fmt。可以运行go help来查看内置文档的索引

```go
$ go
...
    build            compile packages and dependencies
    clean            remove object files
    doc              show documentation for package or symbol
    env              print Go environment information
    fmt              run gofmt on package sources
    get              download and install packages and dependencies
    install          compile and install packages and dependencies
    list             list packages
    run              compile and run Go program
    test             test packages
    version          print Go version
    vet              run go tool vet on packages

Use "go help [command]" for more information about a command.
...
```

为了让配置操作最小化，go工具非常依赖惯例。如: 

- 给定一个Go源文件的名称，Go语言的工具可以找到源文件对应的包，**因为每个目录只包含了单一的包**，并且包的导入路径对应于工作区的目录结构。
- 给定一个包的导入路径，Go语言的工具可以找到存放目标文件的对应目录。也可以根据导入路径找到存储代码的仓库的远程服务器URL。
**工作区结构：****大多数的Go语言用户只需要进行唯一的配置是GOPATH**，它指定工作空间的根。当需要切换到不同的工作空间时，更新GOPATH变量的值即可。如在编写本书时将GOPATH设置为`$HOME/gobook`： GOPATH有三个子目录。

- src子目录包含源文件。每一个包放在一个目录中，该目录相对于$GOPATH/src的名字是包的导入路径，如 [gopl.io/ch1/helloworld](http://gopl.io/ch1/helloworld)；
- pkg子目录是构建工具存储编译后的包的位置；
- bin子目录放置像helloworld这样的可执行程序；
    ```go
    $ export GOPATH=$HOME/gobook
    $ go get gopl.io/...
    ```
`go env`命令用于查看Go语言工具涉及的所有环境变量的值，包括未设置环境变量的默认值。GOOS环境变量用于指定目标操作系统（例如android、linux、darwin或windows），GOARCH环境变量用于指定处理器的类型，例如amd64、386或arm等。虽然GOPATH环境变量是唯一必须要设置的，但是其它环境变量也会偶尔用到。

```go
$ go env
GOPATH="/home/gopher/gobook"
GOROOT="/usr/local/go"
GOARCH="amd64"
GOOS="darwin"
...
```



**包的下载**：go get命令可以下载单一的包，也可以使用...符号来下载子树或仓库。在go get完成包的下载之后，它会构建它们，然后安装库和相应的命令。

**包的构建：**`go build`命令编译命令行参数指定的每个包。如果包是一个库，结果会被舍弃；这可以用于检测包是可以正确编译的。如果包的名字是main，`go build`将调用链接器在当前目录创建一个可执行程序，可执行程序的名字取导入路径的最后一段。

**由于每个目录只包含一个包，因此每个可执行程序或者叫Unix命令都需要放到一个独立的目录中**。如 [golang.org/x/tools/cmd/godoc](http://golang.org/x/tools/cmd/godoc) 命令

如果包名是main，可执行程序的名字来自第一个.go文件名的主体部分；

对于即用即抛型的程序，我们需要在构建之后尽快运行。go run命令将这两步合并起来；



默认情况下，go build命令构建所有需要的包以及它们所有的依赖性，然后丢弃除了最终可执行程序之外的所有编译后的代码。依赖性分析和编译本身都非常快，**但当项目增长到数十个包和数十万行代码的时候，重新编译依赖性的时间明显变慢，也许数秒钟的时间，即使依赖的部分根本没有改变过**；

`go install`命令和`go build`命令很相似，但是它会保存每个包的编译成果，而不是将它们都丢弃。被编译的包会被保存到$GOPATH/pkg目录下，目录路径和 src目录路径对应，可执行程序被保存到$GOPATH/bin目录。（很多用户会将$GOPATH/bin添加到可执行程序的搜索列表中。）还有，`go install`命令和`go build`命令都不会重新编译没有发生变化的包，这可以使后续构建更快捷

为了方便编译依赖的包，`go build -i`命令将安装每个目标所依赖的包。



针对不同操作系统或CPU的交叉构建也是很简单的。只需要设置好目标对应的GOOS和GOARCH，然后运行构建命令即可。下面交叉编译的程序将输出它在编译时的操作系统和CPU类型：

```go
func main() {
    fmt.Println(runtime.GOOS, runtime.GOARCH)
}

// 下面以64位和32位环境分别编译和执行：
$ go build gopl.io/ch10/cross
$ ./cross
darwin amd64

$ GOARCH=386 go build gopl.io/ch10/cross
$ ./cross
darwin 386
```

有些包可能需要针对不同平台和处理器类型使用不同版本的代码文件，以便于处理底层的可移植性问题或为一些特定代码提供优化。如果一个文件名包含了一个操作系统或处理器类型名字，例如net_linux.go或asm_amd64.s，Go语言的构建工具将只在对应的平台编译这些文件。还有一个特别的构建注释参数可以提供更多的构建过程控制。例如，文件中可能包含下面的注释：

```shell
// +build linux darwin
```

在包声明和包注释的前面，该构建注释参数告诉`go build`只在编译程序对应的目标操作系统是Linux或Mac OS X时才编译这个文件。下面的构建注释则表示不编译这个文件：

```shell
// +build ignore
```



**包的文档化：Go风格强烈鼓励有良好的包API文档。每一个导出的包成员的声明以及包声明自身应该立刻使用注释来描述它的目的和用途。**

**Go文档注释应当保持简洁，文档需要像代码一样维护**。使用声明的包名作为开头的第一句注释通常是总结。函数参数和其他的标识符并不需要用引号或括号特别标注。

```go
// **Fprintf** formats according to a format specifier and writes to w.
// It returns the number of bytes written and any write error encountered.
// 第一行通常是摘要说明，以被注释者的名字开头。注释中函数的参数或其它的标识符并不需要额外的引号或其它标记注明。
func Fprintf(w io.Writer, format string, a ...interface{}) (int, error)

// Fprintf函数格式化的细节在fmt包文档中描述。如果注释后紧跟着包声明语句，那注释对应整个包的文档。包文档对应的注释只能有一个（译注：其实可以有多个，它们会组合成一个包文档注释），包注释可以出现在任何一个源文件中。
// 如果包的注释内容比较长，一般会放到一个独立的源文件中；fmt包注释就有300行之多。这个专门用于保存包文档的源文件通常叫doc.go。
```

比较长的包注释可以使用一个单独的注释文件，fmt的注释超过300行，文件名通常叫doc.go；

```go
$ go doc time  // 打印其后所指定的实体的声明与文档注释，如一个包
$ go doc time.Since  // 某个具体的包成员
$ go doc time.Duration.Seconds  // 一个方法
$ go doc json.decode  // 该命令并不需要输入完整的包导入路径或正确的大小写
```

godoc的在线服务 [https://godoc.org](https://godoc.org/) ，包含了成千上万的开源包的检索工具。

```go
$ godoc -http :8000 // 其中-analysis=type和-analysis=pointer命令行标志参数用于打开文档和代码中关于静态分析的结果。
// 在浏览器查看 http://localhost:8000/pkg 页面
```



**internal包：Go语言的构建工具对包含internal名字的路径段的包导入路径做了特殊处理，一个internal包只能被和internal目录有同一个父目录的包所导入**。

这种方式定义标识符可以被一个小的可信任的包集合访问，但不是所有人可以访问；如：当我们计划将一个大的包拆分为很多小的更容易维护的子包，但是我们并不想将内部的子包结构也完全暴露出去； 

如，net/http/internal/chunked内部包只能被net/http/httputil或net/http包导入，但是不能被net/url包导入。不过net/url包却可以导入net/http/httputil包。

```go
net/http
net/http/**internal**/chunked
net/http/httputil
net/url
```



**包的查询：go list工具上报可用包的信息**

```go
$ go list github.com/go-sql-driver/mysql
github.com/go-sql-driver/mysql

$ go list ...  // 列出工作区中的所有包

$ go list gopl.io/ch3/...  // 或者是特定子目录下的所有包

$ go list ...xml...  // 或者是和某个主题相关的所有包

$ go list -json hash  // 获取每个包完整的元信息
```





**包的初始化：****首先是解决包级变量的依赖顺序**，**然后按照包级变量声明出现的顺序依次初始化**：

```go
var a = b + c // a 第三个初始化, 为 3
var b = f()   // b 第二个初始化, 为 2, 通过调用 f (依赖c)
var c = 1     // c 第一个初始化, 为 1

func f() int { return c + 1 }
```

如果包中含有多个.go源文件，它们将按照发给编译器的顺序进行初始化，Go语言的构建工具**首先会将.go文件根据文件名排序****，然后依次调用编译器编译**。

对于在包级别声明的变量，如果**有初始化表达式则用表达式初始化**，还有一些没有初始化表达式的（如某些表格数据初始化并不是一个简单的赋值过程）**可以用一个特殊的init初始化函数来简化初始化工作**。每个文件都可以包含多个init初始化函数。这样的init初始化函数**除了不能被调用或引用外**，其他行为和普通函数类似。在每个**文件中的init**初始化函数，**在程序开始执行时按照它们声明的顺序****被自动调用**。

```go
func init() { /* ... */ }
```

每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。

初始化工作是**自下而上进行的**，**main包最后被初始化**。可以确保在main函数执行之前，所有依赖的包都已经完成初始化工作了。



## 二、Go mod

> 💡 go module = go.mod + package + subs…

go.mod文件：存储了模块路径、编译器版本，以及依赖项列表。

模块是依赖管理方式，是发布和版本控制单元。

如果子目录包含 go.mod，那么它将是独立模块，不再属于当前模块。



```shell
$ go mod init openapi.  # 初始化模块
go: creating new go.mod: module openapi
```



**依赖管理：**

```shell
$ go get [example.com/my@lastet](http://example.com/my@lastet)   # 添加、下载（更新）依赖项 
```

1. 从 GOPROXY 下载源码到本地缓存 GOMODCACHE 目录
1. 向 go.mod go.sum 添加依赖项和验证信息
1. 使用 go clean -modcache 清除缓存（自动重新下载）
```shell
$ go mod tidy # 添加遗漏的、移除不必要的依赖项
$ go mod edit -require  example.com/my@v1.3.4
```



**版本标识：**

```shell
v(major).(minor).(patch)-(pre|beta)
  主要     次要     补丁    预发行或测试版
  
v1.2.3
v1.2.3-pre
v1.5.0-beta

v0.0.0-20191109021931-daa7c04131f5 --> go get example.com/my@daa7c041
```



**工作空间**（workspace）：解决多模块开发遇到的问题。

- 编译时，找不到未发布模块（非子包）。
- 只能以 replace  将模块路径替换为本地路径。
- 污染的 go.mod 意外提交到代码仓库。
```shell
$ go work init # 初始化工作空间
$ go work use ./test ./mylib
```



```shell
// go.work
go 1.18

use (
	./test 
	./mylib
)
```



***更多详情，见官方文档****：*

[https://go.dev/ref/mod](https://go.dev/ref/mod) 

[https://go.dev/doc/modules/managing-dependencies](https://go.dev/doc/modules/managing-dependencies)



# 三、Go test

> *莫里斯·威尔克斯(Maurice Wilkes)设计和制造了世界上第一台存储程序式计算机EDSAC，在1949年有一次实验室爬楼梯时有一个顿悟：“****我强烈地意识到我余生的很大一部分时间，都将用来寻找我程序中的错误。****”*



今天的软件项目比威尔克斯年代的要庞大、复杂得多，并且在使软件复杂度可以控制的技术上面，人们投入了大量的精力。其中有两种技术尤其有效：

- 在被正式部署前需要进行**代码评审**。
- **测试。**这里一般是指自动化测试，**即编写简单的程序来确保程序（产品代码）在该测试中针对特定输入产生预期的输出。**这些测试通常要么是经过精心设计之后用来检测某种功能，要么是随机性的，用来扩大测试的覆盖面。（费曼学习法延展： 字节的产品ABTest、 产品的最小可行性验证）
Go的测试方法依赖于命令`go test`和测试函数的编写约定。这个相对轻量级的机制对单纯的测试很有效，并且这种方式也很自然地扩展到基准测试和文档系统的示例。



在`*_test.go`文件中，是go test编译的目标（不是go build命令编译的目标）。有三种类型的函数需要特殊对待：

- **基准测试函数Benchmark*：以Benchmark前缀命名的函数，用于测试一些函数的性能；go test命令会多次运行基准测试函数以计算出一个平均的执行时间。**
- **示例函数Example*：以Example前缀命名的函数，用来提供提供一个由编译器保证正确性的示例文档。**
- go test工具扫描*_test.go文件来寻找这三种特殊函数，**并生成一个临时的main包来调用它们**，然后编译/构建（go build）和运行(go run)，并汇报结果，最后清空临时文件。
### **功能测试函数Test***

**用来检测一些程序逻辑的正确性。**

**go test运行测试函数，并且报告结果是PASS还是FAIL。**

必须以Test开头，且可选的后缀名称也必须以大写字母开头:

```go
func TestSin(t *testing.T) { /* ... */ }
func TestCos(t *testing.T) { /* ... */ }
func TestLog(t *testing.T) { /* ... */ }
```

每个测试函数必须导入testing包。测试函数有如下的签名：

```go
import testing
func TestName(t *testing.T) {  // **参数t提供了汇报测试失败和日志记录的功能**
    // ...
}
```

**编写函数：**

```go
// Package word provides utilities for word games.
package word

// IsPalindrome reports whether s reads the same forward and backward.
// (Our first attempt.)
func IsPalindrome(s string) bool {
    for i := range s {
        if s[i] != s[len(s)-1-i] {
            return false
        }
    }
    return true
}
```

**编写测试函数：**

```go
package word

import "testing"

func TestPalindrome(t *testing.T) {
    if !IsPalindrome("detartrated") {
        t.Error(`IsPalindrome("detartrated") = false`)
    }
    if !IsPalindrome("kayak") {
        t.Error(`IsPalindrome("kayak") = false`)
    }
}

func TestNonPalindrome(t *testing.T) {
    if IsPalindrome("palindrome") {
        t.Error(`IsPalindrome("palindrome") = true`)
    }
}
```

**发现线上Bug**：一个法国名为“Noelle Eve Elleon”的用户会抱怨IsPalindrome函数不能识别“été”。另外一个来自美国中部用户的抱怨则是不能识别“A man, a plan, a canal: Panama.”；

**定位原因**：

- **先写go test测试用例（运行go test比手动测试bug报告中的内容要快得多）**，然后确保它触发的错误和用户bug报告里面的一致，以定位到bug原因；
    ```go
    func TestFrenchPalindrome(t *testing.T) {
        if !IsPalindrome("été") {
            t.Error(`IsPalindrome("été") = false`)  // 原因：非ASCII字符byte类型无法正确处理，用rune类型
        }
    }
    func TestCanalPalindrome(t *testing.T) {
        input := "A man, a plan, a canal: Panama"   
        if !IsPalindrome(input) {      // 原因：没有忽略空格和字母的大小写
            t.Errorf(`IsPalindrome(%q) = false`, input)
        }
    }
    ```
- 参数`-v`可用于打印每个测试函数的名字和运行时间：
    ```go
    $ go test -v
    === RUN TestPalindrome
    --- PASS: TestPalindrome (0.00s)
    === RUN TestNonPalindrome
    --- PASS: TestNonPalindrome (0.00s)
    === RUN TestFrenchPalindrome
    --- FAIL: TestFrenchPalindrome (0.00s)
        word_test.go:28: IsPalindrome("été") = false
    === RUN TestCanalPalindrome
    --- FAIL: TestCanalPalindrome (0.00s)
        word_test.go:35: IsPalindrome("A man, a plan, a canal: Panama") = false
    FAIL
    exit status 1
    FAIL    gopl.io/ch11/word1  0.017s
    ```
- 参数`-run`对应一个正则表达式，只有测试函数名被它正确匹配的测试函数才会被`go test`测试命令运行：
    ```go
    $ go test -v -run="French|Canal"
    === RUN TestFrenchPalindrome
    --- FAIL: TestFrenchPalindrome (0.00s)
        word_test.go:28: IsPalindrome("été") = false
    === RUN TestCanalPalindrome
    --- FAIL: TestCanalPalindrome (0.00s)
        word_test.go:35: IsPalindrome("A man, a plan, a canal: Panama") = false
    FAIL
    exit status 1
    FAIL    gopl.io/ch11/word1  0.014s
    ```
- `go test`命令如果没有参数指定包那么将默认采用当前目录对应的包（和`go build`命令一样）
**修复bug：**

```go
// Package word provides utilities for word games.
package word

import "unicode"

// IsPalindrome reports whether s reads the same forward and backward.
// Letter case is ignored, as are non-letters.
func IsPalindrome(s string) bool {
    var letters []rune
    for _, r := range s {
        if unicode.IsLetter(r) {
            letters = append(letters, unicode.ToLower(r))
        }
    }
    for i := range letters {
        if letters[i] != letters[len(letters)-1-i] {
            return false
        }
    }
    return true
}
```

**回归测试**：在提交代码更新之前，**使用不带参数的go test命令以运行全部的测试用例(回归测试)**，**以确保修复失败测试的同时没有引入新的bug。**



和其他编程语言或测试框架的assert断言不同，t.Errorf调用也没有引起panic异常或停止测试的执行。

即使表格中前面的数据导致了测试的失败，表格后面的测试数据依然会运行测试，因此在一个测试中我们可能了解多个失败的信息。

如果我们真的需要停止测试，或许是因为初始化失败或可能是早先的错误导致了后续错误等原因，我们可以使用t.Fatal或t.Fatalf停止当前测试函数。它们必须在和测试函数同一个goroutine内调用。

在测试的代码里面不要调用log.Fatal或者os.Exit，因为这两个调用会阻止跟踪的过程，这两个函数的调用可以认为是main函数的特权。



**测试失败的信息一般的形式：“f(x) = y, want z”**。其中f(x)解释了失败的操作和对应的输入，y是实际的运行结果，z是期望的正确的结果。**要避免无用和冗余的信息**。测试的作者应该要努力帮助程序员诊断测试失败的原因。



**两种测试样例：**

- **基于测试用例表的测试方式**：将之前的所有测试用例合并到了一个测试表格中很直观
    ```go
    func TestIsPalindrome(t *testing.T) {
        var tests = []struct {
            input string
            want  bool
        }{
            {"", true},
            {"a", true},
            {"aa", true},
            {"ab", false},
            {"kayak", true},
            {"detartrated", true},
            {"A man, a plan, a canal: Panama", true},
            {"Evil I did dwell; lewd did I live.", true},
            {"Able was I ere I saw Elba", true},
            {"été", true},
            {"Et se resservir, ivresse reste.", true},
            {"palindrome", false}, // non-palindrome
            {"desserts", false},   // semi-palindrome
        }
        for _, test := range tests {
            if got := IsPalindrome(test.input); got != test.want {
                t.Errorf("IsPalindrome(%q) = %v", test.input, got)
            }
        }
    }
    ```
    - **随机测试**：通过构建随机输入来扩展测试的覆盖范围。由于随机测试的不确定性，在遇到测试用例失败的情况下，一定要记录足够的信息以便于复现问题，如记录伪随机数生成器的种子。
**黑盒测试**：假设测试者对包的了解仅通过公开的API和文档，而包的内部逻辑则是不透明的。如TestIsPalindrome函数仅调用导出的函数IsPalindrome。

**白盒测试**：可以访问包的内部函数和数据结构，并且可以做一些常规用户无法做到的观察和改动。黑盒测试通常更加健壮，每次程序更新后基本不需要修改。白盒测试可以对实现的特定之处提供更详细的覆盖测试。如TestEcho函数调用echo函数并且更新全局变量out，无论函数echo还是变量out都是未导出的。

**Mock模拟**：可以使用易于测试的伪实现来替换部分产品代码。这种Mock模拟的伪实现的优点是**更易于配置、预测和观察，并且更可靠**。它们还能够**避免带来副作用**，**如更新产品数据库或者刷信用卡**。

**外部测试包**：低级别包的测试导入了高级别包会导致包循环引用而产生编译错误，将这个测试函数定义在外部测试包中来解决这个问题。在net/url目录中，外部测试包的声明是url_test 独立的一个包；

有时候，外部测试包需要对待测试包拥有特殊的访问权限，例如为了避免循环引用，一个白盒测试必须存在于一个单独的包中。在这种情况下，我们使用一种小技巧：在包内测试文件_test.go中添加一些函数声明，将包内部的功能暴露给外部测试。这些文件也因此为测试提供了包的一个“后门”。如果一个源文件存在的唯一目的就在于此，并且自己不包含任何测试，它们一般称作export_test.go。



**编写有效测试**：

其他语言的框架提供了识别测试函数的机制（一般通过反射或者元数据），在测试前后执行测试“启动”和“销毁”的钩子，以及为常规的断言、值比较、错误消息格式化和终止失败的测试（一般通过抛出异常的方式）提供工具方法的库。但导致的结果是这些测试看上去像是用一门其他的语言编写的。

Go对测试的看法是完全不同的。它期望测试的编写者自己来做大部分的工作，通过定义函数来避免重复，就像他们为普通程序所做的那样。测试的过程不是死记硬背地填表格；测试也是有用户界面的，虽然它的用户也是它的维护者。一个好的测试不会在发生错误时崩溃而是输出该问题一个简洁、清晰的现象描述，以及其他与上下文相关的信息。**理想情况下，维护者通过测试输出结果，而不需要再通过阅读源代码来探究测试失败的原因（同打Log）**。一个好的测试不应该在发现一次测试失败后就终止，而是要在一次运行中尝试报告多个错误，因为错误发生的方式本身会揭露错误的原因。

```go
import (
    "fmt"
    "strings"
    "testing"
)
// A poor assertion function.
func assertEqual(x, y int) {
    if x != y {
        panic(fmt.Sprintf("%d != %d", x, y))
    }
}
func TestSplit(t *testing.T) {
    words := strings.Split("a:b:c", ":")
    assertEqual(len(words), 3)     // 断言函数犯了过早抽象的错误：仅仅测试两个整数是否相同，而没能根据上下文提供更有意义的错误信息。
    // ...
}

func TestSplit(t *testing.T) {
    s, sep := "a:b:c", ":"
    words := strings.Split(s, sep)
    if got, want := len(words), 3; got != want {    
        t.Errorf("Split(%q, %q) returned %d words, want %d",         // **不仅报告了调用的具体函数、它的输入和结果的意义；并且打印的真实返回的值和期望返回的值；并且即使断言失败依然会继续尝试运行更多的测试**
            s, sep, got, want)
    }
    // ...
}
```

避免脆弱的测试：如果一个应用在遇到新的合法输入的情况下经常崩溃，那么这个程序是有缺陷的；如果在程序发生可靠的改动的时候测试用例奇怪地失败了，那么这个测试用例也是脆弱的。**最脆弱的测试在产品代码发生任何改动的时候都会失败，无论这些改动是好是坏**，这些测试通常称为**变化探测器(changedetector)或现状探测器(status quo test)**，并且处理它们花费的时间将会使得它们曾经带来的好处消失殆尽。

从本质上看，测试不可能是完整的。著名计算机科学家EdsgerDijkstra说，“测试能证明bug存在，而无法证明bug不存在。” 无论有多少测试都无法证明一个包是没有bug的。在最好的情况下，测试可以增强了我们的信心，这些包是可以在很多重要的场景下正常工作的。（类似渗透测试相对的证明系统的安全性）；



**测试覆盖率**：对待测程序执行的测试的比例称为测试的覆盖率；

- 语句的覆盖率是指在测试中至少被运行一次的代码占总代码数的比例。**在运行每个测试前，它将待测代码拷贝一份并做修改，在每个词法块都会设置一个布尔标志变量。当被修改后的被测试代码运行退出时，将统计日志数据写入c.out文件，并打印一部分执行的语句的一个总结。**
- 如果使用了`-covermode=count`标志参数，那么将在每个代码块插入一个计数器而不是布尔标志量。在统计结果中记录了每个块的执行次数，这可以用于衡量哪些是被频繁执行的热点代码。
    - 红色的则表示没有被覆盖到，于是在添加下面的测试用例，确保红色部分的未测试的代码也变成绿色已测试的代码了
    - 实现100%的测试覆盖率听起来很美，但是在具体实践中通常是不可行的，也不是值得推荐的做法。因为那只能说明代码被执行过而已，并不意味着代码就是没有BUG的；因为对于逻辑复杂的语句需要针对不同的输入执行多次。有一些语句，例如上面的panic语句则永远都不会被执行到。另外，还有一些隐晦的错误在现实中很少遇到也很难编写对应的测试代码。测试从本质上来说是一个比较务实的工作，**编写测试代码和编写应用代码的成本对比是需要考虑的**。测试覆盖率工具可以帮助我们快速识别测试薄弱的地方，但是设计好的测试用例和编写应用代码一样需要严密的思考。
![](/images/23c24637-29b5-8014-bcb6-d0963c7c66e3/image_1e224637-29b5-809e-a2ed-e1d681b8ba61.jpg)

```go
$ go tool cover -html=c.out
```

```go
$ go test -run=Coverage -coverprofile=c.out gopl.io/ch7/eval
ok      gopl.io/ch7/eval         0.032s      coverage: 68.5% of statements
```



### **基准测试函数/压测函数 Benchmark***

基准测试是测量一个程序在固定工作负载下的性能。和普通测试函数写法类似，但以Benchmark为前缀名，并且带有一个`*testing.B`类型的参数；`*testing.B`参数除了提供和`*testing.T`类似的方法，还有额外一些和性能测量相关的方法。它还提供了一个整数N，用于指定操作执行的循环次数。

| 特性 | 基准测试**（Benchmark）** | 压力测试**（Stress Test）** | 
| --- | --- | --- | 
| **目的** | 测量性能指标 | 测试系统稳定性 | 
| **范围** | 单个函数/组件 | 整个系统 | 
| **负载** | 正常负载 | 高负载/极限负载 | 
| **时间** | 短期测试 | 长期测试 | 
| **指标** | 执行时间、内存使用 | 吞吐量、响应时间、错误率 | 
| **环境** | 受控环境 | 模拟真实环境 | 

```go
// 基准测试：测量单个操作的性能。目的：测量代码的执行时间和资源消耗
func BenchmarkAdd(b *testing.B) {
    for i := 0; i < b.N; i++ {
        add(1, 2)
    }
}

// 压力测试：测量系统在高负载下的表现。目的：测试系统在高负载下的稳定性和性能
func TestSystemUnderLoad(t *testing.T) {
    // 模拟大量并发请求
    for i := 0; i < 1000; i++ {
        go func() {
            // 发送请求
            response := sendRequest()
            // 验证响应
        }()
    }
}
```



默认情况下不运行任何基准测试，**需要通过**`**-bench**`**命令行标志参数手工指定要运行的基准测试函数**。该参数是一个正则表达式，用于匹配要执行的基准测试函数的名字，默认值是空的。其中“.”模式将可以匹配所有基准测试函数，但因为这里只有一个基准测试函数，因此和`-bench=IsPalindrome`参数是等价的效果。

- 结果中基准测试名的数字后缀部分，这里是8，表示运行时对应的GOMAXPROCS的值，这对于一些与并发相关的基准测试是重要的信息。
- 报告显示每次调用IsPalindrome函数花费1.035微秒，是执行1,000,000次（一百万次）的平均时间；
- 因为基准测试驱动器开始时并不知道每个基准测试函数运行所花的时间，它会尝试在真正运行基准测试前先尝试用较小的N运行测试来估算基准测试函数所需要的时间，然后推断一个较大的时间保证稳定的测量结果。
- 循环在基准测试函数内实现，而不是放在基准测试框架内实现，这样可以让每个基准测试函数有机会在循环启动前执行初始化代码，这样并不会显著影响每次迭代的平均运行时间。如果还是担心初始化代码部分对测量时间带来干扰，那么可以通过testing.B参数提供的方法来临时关闭或重置计时器，不过这些一般很少会用到。
```go
$ cd $GOPATH/src/gopl.io/ch11/word2
$ go test -bench=.
PASS
BenchmarkIsPalindrome-8 1000000                1035 ns/op
ok      gopl.io/ch11/word2      2.179s
```

IsPalindrome函数性能优化：

```go
n := len(letters)/2
for i := 0; i < n; i++ {
    if letters[i] != letters[len(letters)-1-i] {   
        return false     // 避免每个比较都做两次
    }
}
return true

$ go test -bench=.
PASS
BenchmarkIsPalindrome-8 1000000              992 ns/op   // 性能+4%
ok      gopl.io/ch11/word2      2.093s  
```

再优化：在开始为每个字符预先分配一个足够大的数组，这样就可以避免在append调用时可能会导致内存的多次重新分配

```go
letters := make([]rune, 0, len(s))
for _, r := range s {
    if unicode.IsLetter(r) {
        letters = append(letters, unicode.ToLower(r))
    }
}

$ go test -bench=.
PASS
BenchmarkIsPalindrome-8 2000000                      697 ns/op   // 性能+35%
ok      gopl.io/ch11/word2      1.468s

```

例子证明：快的程序往往是伴随着较少的内存分配。用一次内存分配代替多次的内存分配，节省了75%的分配调用次数和减少近一半的内存需求。

```go
$ go test -bench=. -benchmem
PASS
BenchmarkIsPalindrome    1000000   1026 ns/op    304 B/op  4 allocs/op   // 优化后

$ go test -bench=. -benchmem   
PASS
BenchmarkIsPalindrome    2000000    807 ns/op    128 B/op  1 allocs/op   // 优化后

```

比较型的基准测试就是普通程序代码。它们通常是单参数的函数，由几个不同数量级的基准测试函数调用，就像这样：

- 通过函数参数来指定输入的大小，但是参数变量对于每个具体的基准测试都是固定的。要避免直接修改b.N来控制输入的大小。除非你将它作为一个固定大小的迭代计算输入，否则基准测试的结果将毫无意义。
- 比较型的基准测试反映出的模式在程序设计阶段是很有帮助的，但是即使程序完工了也应当保留基准测试代码。因为随着项目的发展，或者是输入的增加，或者是部署到新的操作系统或不同的处理器，我们可以再次用基准测试来帮助我们改进设计。
```go
func benchmark(b *testing.B, size int) { /* ... */ }
func Benchmark10(b *testing.B)         { benchmark(b, 10) }
func Benchmark100(b *testing.B)        { benchmark(b, 100) }
func Benchmark1000(b *testing.B)       { benchmark(b, 1000) }
```



### **性能剖析**

> 唐纳德·克努斯 的不要**过早优化**的箴言：



- 基准测试（Benchmark）对于衡量特定操作的性能是有帮助的，但是当我们试图让程序跑的更快的时候，我们通常并不知道从哪里开始优化。
- **性能剖析**：通过自动化手段在程序执行过程中基于一些性能事件的采样来进行性能评测，然后再从这些采样中推断分析，得到的统计报告就称作为性能剖析(profile)。
    - 每个CPU上面执行的线程都每隔几毫秒会定期地被操作系统中断，在每次中断过程中记录一个性能剖析事件，然后恢复正常执行。
    - 堆性能剖析识别出负责分配最多内存的语句。性能剖析库对协程内部内存分配调用进行采样，因此每个性能剖析事件平均记录了分配的512KB内存。
    - 阻塞性能剖析识别出那些阻塞goroutine最久的操作，例如系统调用，通道发送和接收数据，以及获取锁等。性能分析库在一个goroutine每次被上述操作之一阻塞的时候记录一个事件。
    - 获取待测试代码的性能剖析报告很容易，只需要像下面一样指定一个标记即可。当一次使用多个标记的时候需要注意，获取性能分析报告的机制是当获取其中一个类别的报告时会覆盖掉其他类别的报告。
    - 在我们获取性能剖析结果后，我们需要使用pprof工具来分析它。这是Go发布包的标准部分，但是因为不经常使用，所以通过go tool pprof间接来使用它。它有很多特性和选项，但是基本的用法只有两个参数，产生性能剖析结果的可执行文件和性能剖析日志。
    - 为了提高分析效率和减少空间，分析日志本身并不包含函数的名字；它只包含函数对应的地址。也就是说pprof需要对应的可执行程序来解读剖析数据。虽然`go test`通常在测试完成后就丢弃临时用的测试程序，但是在启用分析的时候会将测试程序保存为foo.test文件，其中foo部分对应待测包的名字。
    - 下面的命令演示了如何收集并展示一个CPU分析文件。我们选择`net/http`包的一个基准测试为例。通常最好是对业务关键代码的部分设计专门的基准测试。因为简单的基准测试几乎没法代表业务场景，因此我们用-run=NONE参数禁止那些简单测试。
        - 参数`-text`用于指定输出格式，在这里每行是一个函数，根据使用CPU的时间长短来排序。其中`-nodecount=10`参数限制了只输出前10行的结果。对于严重的性能问题，这个文本格式基本可以帮助查明原因了。
        - 这个概要文件告诉我们，HTTPS基准测试中`crypto/elliptic.p256ReduceDegree`函数占用了将近一半的CPU资源，对性能占很大比重。相比之下，如果一个概要文件中主要是runtime包的内存分配的函数，那么减少内存消耗可能是一个值得尝试的优化策略。
        - 对于一些更微妙的问题，你可能需要使用pprof的图形显示功能。这个需要安装GraphViz工具，可以从 [http://www.graphviz.org](http://www.graphviz.org/) 下载。参数`-web`用于生成函数的有向图，标注有CPU的使用和最热点的函数等信息。
    ```go
    $ go test -run=NONE -bench=ClientServerParallelTLS64 \
        -cpuprofile=cpu.log net/http
     PASS
     BenchmarkClientServerParallelTLS64-8  1000
        3141325 ns/op  143010 B/op  1747 allocs/op
    ok       net/http       3.395s
    $ go tool pprof -text -nodecount=10 ./http.test cpu.log
    2570ms of 3590ms total (71.59%)
    Dropped 129 nodes (cum <= 17.95ms)
    Showing top 10 nodes out of 166 (cum >= 60ms)
        flat  flat%   sum%     cum   cum%
      1730ms 48.19% 48.19%  1750ms 48.75%  crypto/elliptic.p256ReduceDegree
       230ms  6.41% 54.60%   250ms  6.96%  crypto/elliptic.p256Diff
       120ms  3.34% 57.94%   120ms  3.34%  math/big.addMulVVW
       110ms  3.06% 61.00%   110ms  3.06%  syscall.Syscall
        90ms  2.51% 63.51%  1130ms 31.48%  crypto/elliptic.p256Square
        70ms  1.95% 65.46%   120ms  3.34%  runtime.scanobject
        60ms  1.67% 67.13%   830ms 23.12%  crypto/elliptic.p256Mul
        60ms  1.67% 68.80%   190ms  5.29%  math/big.nat.montgomery
        50ms  1.39% 70.19%    50ms  1.39%  crypto/elliptic.p256ReduceCarry
        50ms  1.39% 71.59%    60ms  1.67%  crypto/elliptic.p256Sum
    ```


### **示例函数 Example***

示例函数没有函数参数和返回值。下面是IsPalindrome函数对应的示例函数：

示例函数有三个用处。

- 最主要的一个是作为文档
- 第二个用处是，在`go test`执行测试的时候也会运行示例函数测试。
- 第三个目的提供一个真实的演练场。如： [http://golang.org](http://golang.org/)


