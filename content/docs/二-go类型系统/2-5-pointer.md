---
title: "2.5 pointer"
date: 2025-03-30T11:53:00Z
draft: false
weight: 2005
---

# 2.5 pointer

- **变量存储值，变量被称为****可寻址的值****，对应一个保存了变量对应类型值的****内存地址**。通过变量名或表达式访问（如x[i]或x.f），必定能接受`&`取地址操作；**一个指针对应变量的内存地址，**通过指针可以绕过变量的名字**直接读或更新对应变量的值****；**
- 每次我们对一个变量取地址(p := &v)，或者复制指针，我们都是为原变量创建了新的别名。例如，`*p`就是变量v的别名。*指针特别有价值的地方在于我们可以不用名字而访问一个变量*，但是这是一把双刃剑：**要找到一个变量的所有访问者并不容易**，我们必须知道变量全部的别名（译注：**这是Go语言的垃圾回收器所做的工作**）。不仅仅是指针会创建别名，很多其他引用类型也会创建别名，例如slice、map和chan，甚至结构体、数组和接口**都会创建所引用变量的别名**。
- 如果用“var x int”声明语句声明一个x变量，那么&x表达式（取x变量的内存地址）将产生一个指向该整数变量的指针；对于聚合类型每个成员，如结构体的每个字段、或者是数组的每个元素——也都是对应一个变量，因此可以被取地址。
    ```go
    x := 1
    // &x: 读取x变量的内存地址；p指针指向变量、p指针保存了x变量的内存地址，**其数据类型为 *int** （**指向int类型的指针**）
    p := &x         // p, of type *int, points to x 
    // *p: 读取p指针指向的变量的值
    fmt.Println(*p) // "1"
    // 因为*p对应一个变量，所以可以赋值语句更新指针所指向的变量的值。
    *p = 2          // equivalent to x = 2
    fmt.Println(x)  // "2"
    ```
- Go中**函数中返回局部变量的地址也是安全的**。因为指针p依然引用这个变量，Go中的GC使用的简单的标记清除算法的可达性树法不会识别为垃圾变量，但这会导致内存泄露；
    ```go
    // point study
    package main
    import "fmt"
    func main() {
    	// 在局部变量地址&v被返回之后依然有效，因为指针p依然引用这个变量。
    	var p = f()
    	fmt.Println(p)
    	fmt.Println(f() == f()) // "false"
    }
    func f() *int {
    	v := 1
    	return &v
    }
    ```
- 如果将指针作为参数调用函数，可以在函数中通过该指针来更新变量的值。（译注：这是对C语言中`++v`操作的模拟，这里只是为了说明指针的用法，incr函数模拟的做法并不推荐）：
    ```go
    // incr study
    package main
    import "fmt"
    func main() {
    	v := 1
    	incr(&v)              // v = 2,return 2
    	fmt.Println(incr(&v)) // v = 3 return 3
    }
    func incr(p *int) int {
    	*p++ // 非常重要：只是增加p指向的变量的值，并不改变p指针！！！
    	return *p
    }
    ```


### Echo4.go

标准库中的flag包的关键技术为大量使用到了指针，它使用命令行参数来设置对应变量的值。

为了说明这一点，在早些的echo版本中，就包含了两个可选的命令行参数：`-n`用于忽略行尾的换行符，`-s sep`用于指定分隔字符（默认是空格）。下面这是第四个版本，对应包路径为gopl.io/ch2/echo4。



调用flag.Bool函数会创建一个新的对应布尔型标志参数的变量。它有三个属性：第一个是命令行标志参数的名字“n”，然后是该标志参数的默认值（这里是false），最后是该标志参数对应的描述信息。

如果用户在命令行输入了一个无效的标志参数，或者输入`-h`或`-help`参数，那么将打印所有标志参数的名字、默认值和描述信息。



```go
// Echo4 prints its command-line arguments.
// See page 33.
package main

import (
	"flag"
	"fmt"
	"strings"
)

// 定义命令行参数名、默认值、和描述信息。
var n = flag.Bool("n", false, "omit trailing newline") // *bool类型的指针，默认为false不换行（终端会打印出一个%作为无换行符的标识）
var sep = flag.String("s", " ", "separator")           // *string类型的指针，默认为空格

func main() {
	// 解析命令行参数，更新每个标志参数对应变量的值（之前是默认值）。
	// 解析命令行参数时遇到错误，默认将打印相关的提示信息，然后调用os.Exit(2)终止程序。
	flag.Parse()
	fmt.Print(strings.Join(flag.Args(), *sep)) // 打印命令行参数，*sep 是一个字符串指针，它的值是通过命令行参数 -s 指定的分隔符。

	if !*n { // 如果命令行参数 -n 没有指定，就打印一个换行符
		fmt.Println()
	}
}
```



